<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Inheritance and Polymorphism: BinTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Inheritance and Polymorphism
   &#160;<span id="projectnumber">4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classBinTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BinTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bintree_8h_source.html">bintree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree_1_1Node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ace8123d5e45d15164e5962184667d51a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#ace8123d5e45d15164e5962184667d51a">BinTree</a> ()</td></tr>
<tr class="memdesc:ace8123d5e45d15164e5962184667d51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#ace8123d5e45d15164e5962184667d51a">More...</a><br /></td></tr>
<tr class="separator:ace8123d5e45d15164e5962184667d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0142cad3ef4f3c340971f67b3a279056"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a0142cad3ef4f3c340971f67b3a279056">~BinTree</a> ()</td></tr>
<tr class="memdesc:a0142cad3ef4f3c340971f67b3a279056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a0142cad3ef4f3c340971f67b3a279056">More...</a><br /></td></tr>
<tr class="separator:a0142cad3ef4f3c340971f67b3a279056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa469f4a964beb792cb138b9230567a78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#aa469f4a964beb792cb138b9230567a78">insert</a> (<a class="el" href="classGeneric.html">Generic</a> *newData)</td></tr>
<tr class="memdesc:aa469f4a964beb792cb138b9230567a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a value into the <a class="el" href="classBinTree.html">BinTree</a>  <a href="#aa469f4a964beb792cb138b9230567a78">More...</a><br /></td></tr>
<tr class="separator:aa469f4a964beb792cb138b9230567a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f846c419a9e9a98001389485253b3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a23f846c419a9e9a98001389485253b3e">remove</a> (<a class="el" href="classGeneric.html">Generic</a> &amp;oldData)</td></tr>
<tr class="memdesc:a23f846c419a9e9a98001389485253b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes an entry from the <a class="el" href="classBinTree.html">BinTree</a>  <a href="#a23f846c419a9e9a98001389485253b3e">More...</a><br /></td></tr>
<tr class="separator:a23f846c419a9e9a98001389485253b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdc821a1313dc2ccf34a23fd0abd40b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#afcdc821a1313dc2ccf34a23fd0abd40b">displaySideways</a> () const </td></tr>
<tr class="separator:afcdc821a1313dc2ccf34a23fd0abd40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51e54b66eaf1ef2195576c566acfba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#aa51e54b66eaf1ef2195576c566acfba6">makeEmpty</a> ()</td></tr>
<tr class="memdesc:aa51e54b66eaf1ef2195576c566acfba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty the tree completely  <a href="#aa51e54b66eaf1ef2195576c566acfba6">More...</a><br /></td></tr>
<tr class="separator:aa51e54b66eaf1ef2195576c566acfba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1174457deaf3f8cfb6887455f58f860f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBinTree.html">BinTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a1174457deaf3f8cfb6887455f58f860f">operator=</a> (const <a class="el" href="classBinTree.html">BinTree</a> &amp;other)</td></tr>
<tr class="memdesc:a1174457deaf3f8cfb6887455f58f860f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a1174457deaf3f8cfb6887455f58f860f">More...</a><br /></td></tr>
<tr class="separator:a1174457deaf3f8cfb6887455f58f860f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a2380532b0e7c44869c82732aaf7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#ac6a2380532b0e7c44869c82732aaf7b2">arrayToBSTree</a> (<a class="el" href="classGeneric.html">Generic</a> *[])</td></tr>
<tr class="memdesc:ac6a2380532b0e7c44869c82732aaf7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">conversion routine to input the data from an array into the tree  <a href="#ac6a2380532b0e7c44869c82732aaf7b2">More...</a><br /></td></tr>
<tr class="separator:ac6a2380532b0e7c44869c82732aaf7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b0e5e64e7d15a588f5435962029666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a82b0e5e64e7d15a588f5435962029666">bstreeToArray</a> (<a class="el" href="classGeneric.html">Generic</a> *[])</td></tr>
<tr class="memdesc:a82b0e5e64e7d15a588f5435962029666"><td class="mdescLeft">&#160;</td><td class="mdescRight">conversion routine to output the data in the tree into an array  <a href="#a82b0e5e64e7d15a588f5435962029666">More...</a><br /></td></tr>
<tr class="separator:a82b0e5e64e7d15a588f5435962029666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5ce80f97bb63c0af4995f5917b3d0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a9b5ce80f97bb63c0af4995f5917b3d0f">isEmpty</a> () const </td></tr>
<tr class="memdesc:a9b5ce80f97bb63c0af4995f5917b3d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks for emptiness  <a href="#a9b5ce80f97bb63c0af4995f5917b3d0f">More...</a><br /></td></tr>
<tr class="separator:a9b5ce80f97bb63c0af4995f5917b3d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4bc893858764d61ef993837ba94313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#adb4bc893858764d61ef993837ba94313">retrieve</a> (<a class="el" href="classGeneric.html">Generic</a> &amp;, <a class="el" href="classGeneric.html">Generic</a> *&amp;)</td></tr>
<tr class="memdesc:adb4bc893858764d61ef993837ba94313"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks to see if an entry is in the <a class="el" href="classBinTree.html">BinTree</a>  <a href="#adb4bc893858764d61ef993837ba94313">More...</a><br /></td></tr>
<tr class="separator:adb4bc893858764d61ef993837ba94313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a755f0ef440f55e989f407a0f7d02f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a66a755f0ef440f55e989f407a0f7d02f">size</a> ()</td></tr>
<tr class="memdesc:a66a755f0ef440f55e989f407a0f7d02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">public getter for the size of the tree  <a href="#a66a755f0ef440f55e989f407a0f7d02f">More...</a><br /></td></tr>
<tr class="separator:a66a755f0ef440f55e989f407a0f7d02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5855aafdb96ba09085ae305395b11589"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a5855aafdb96ba09085ae305395b11589">getDepth</a> (<a class="el" href="classGeneric.html">Generic</a> &amp;)</td></tr>
<tr class="memdesc:a5855aafdb96ba09085ae305395b11589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public accessor to determine node's distance from root.  <a href="#a5855aafdb96ba09085ae305395b11589">More...</a><br /></td></tr>
<tr class="separator:a5855aafdb96ba09085ae305395b11589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7f9dd0dc2596d21cb2742819d3a480"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a7d7f9dd0dc2596d21cb2742819d3a480">toStringInorder</a> () const </td></tr>
<tr class="memdesc:a7d7f9dd0dc2596d21cb2742819d3a480"><td class="mdescLeft">&#160;</td><td class="mdescRight">public toString()  <a href="#a7d7f9dd0dc2596d21cb2742819d3a480">More...</a><br /></td></tr>
<tr class="separator:a7d7f9dd0dc2596d21cb2742819d3a480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7570c08ff2a0af5b4ef1f15eb776475c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a7570c08ff2a0af5b4ef1f15eb776475c">operator==</a> (const <a class="el" href="classBinTree.html">BinTree</a> &amp;rhs) const </td></tr>
<tr class="separator:a7570c08ff2a0af5b4ef1f15eb776475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af815543b5532e1acfe6734e3b69aa0ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#af815543b5532e1acfe6734e3b69aa0ef">operator!=</a> (const <a class="el" href="classBinTree.html">BinTree</a> &amp;rhs) const </td></tr>
<tr class="memdesc:af815543b5532e1acfe6734e3b69aa0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">just a boring re-use of operator==  <a href="#af815543b5532e1acfe6734e3b69aa0ef">More...</a><br /></td></tr>
<tr class="separator:af815543b5532e1acfe6734e3b69aa0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8145fa386300e11439d2d3f4a44039a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#ab8145fa386300e11439d2d3f4a44039a">getRoot</a> () const </td></tr>
<tr class="separator:ab8145fa386300e11439d2d3f4a44039a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a86af32f56bdeba35f7d35d1e350dc7cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a86af32f56bdeba35f7d35d1e350dc7cc">preorderCopy</a> (<a class="el" href="classBinTree_1_1Node.html">Node</a> *, <a class="el" href="classBinTree_1_1Node.html">Node</a> *)</td></tr>
<tr class="separator:a86af32f56bdeba35f7d35d1e350dc7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604391bd9d790aa215c947260924546d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a604391bd9d790aa215c947260924546d">postorderDelete</a> (<a class="el" href="classBinTree_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a604391bd9d790aa215c947260924546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for destructor  <a href="#a604391bd9d790aa215c947260924546d">More...</a><br /></td></tr>
<tr class="separator:a604391bd9d790aa215c947260924546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b105deffaa22997cc27bb5c8f0360c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a26b105deffaa22997cc27bb5c8f0360c">insertHelper</a> (<a class="el" href="classBinTree_1_1Node.html">Node</a> *, <a class="el" href="classGeneric.html">Generic</a> *)</td></tr>
<tr class="memdesc:a26b105deffaa22997cc27bb5c8f0360c"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for the public <a class="el" href="classBinTree.html#aa469f4a964beb792cb138b9230567a78" title="inserts a value into the BinTree ">insert()</a>  <a href="#a26b105deffaa22997cc27bb5c8f0360c">More...</a><br /></td></tr>
<tr class="separator:a26b105deffaa22997cc27bb5c8f0360c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b7fde4a52e71c0d3720eb14b51da24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a61b7fde4a52e71c0d3720eb14b51da24">removeHelper</a> (<a class="el" href="classBinTree_1_1Node.html">Node</a> *, <a class="el" href="classGeneric.html">Generic</a> &amp;)</td></tr>
<tr class="memdesc:a61b7fde4a52e71c0d3720eb14b51da24"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method for <a class="el" href="classBinTree.html#a23f846c419a9e9a98001389485253b3e" title="removes an entry from the BinTree ">remove()</a>  <a href="#a61b7fde4a52e71c0d3720eb14b51da24">More...</a><br /></td></tr>
<tr class="separator:a61b7fde4a52e71c0d3720eb14b51da24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc98226686df58f7cdacbc251956649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#aebc98226686df58f7cdacbc251956649">arrayToBSTreeHelper</a> (<a class="el" href="classGeneric.html">Generic</a> *[], int, int)</td></tr>
<tr class="memdesc:aebc98226686df58f7cdacbc251956649"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive helper to extract the middle element in each subarray.  <a href="#aebc98226686df58f7cdacbc251956649">More...</a><br /></td></tr>
<tr class="separator:aebc98226686df58f7cdacbc251956649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4196f4ba0b47589d9a7374dcb04e8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#aef4196f4ba0b47589d9a7374dcb04e8b">retrieve</a> (<a class="el" href="classBinTree_1_1Node.html">Node</a> *, <a class="el" href="classGeneric.html">Generic</a> &amp;, <a class="el" href="classGeneric.html">Generic</a> *&amp;)</td></tr>
<tr class="memdesc:aef4196f4ba0b47589d9a7374dcb04e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">private helper for <a class="el" href="classBinTree.html#aef4196f4ba0b47589d9a7374dcb04e8b" title="private helper for retrieve() ">retrieve()</a>  <a href="#aef4196f4ba0b47589d9a7374dcb04e8b">More...</a><br /></td></tr>
<tr class="separator:aef4196f4ba0b47589d9a7374dcb04e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf448c3ebe63232b970dd8cec46118e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#abf448c3ebe63232b970dd8cec46118e5">getDepthHelper</a> (<a class="el" href="classGeneric.html">Generic</a> &amp;target, <a class="el" href="classBinTree_1_1Node.html">Node</a> *cur, int level)</td></tr>
<tr class="memdesc:abf448c3ebe63232b970dd8cec46118e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">private helper routine to support <a class="el" href="classBinTree.html#a5855aafdb96ba09085ae305395b11589" title="Public accessor to determine node&#39;s distance from root. ">getDepth()</a> recursively  <a href="#abf448c3ebe63232b970dd8cec46118e5">More...</a><br /></td></tr>
<tr class="separator:abf448c3ebe63232b970dd8cec46118e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fef3bfa3e179035f17474007ace8c5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a3fef3bfa3e179035f17474007ace8c5f">getArraySize</a> (<a class="el" href="classGeneric.html">Generic</a> *nodeArray[])</td></tr>
<tr class="memdesc:a3fef3bfa3e179035f17474007ace8c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method to determine the size of an array of pointers  <a href="#a3fef3bfa3e179035f17474007ace8c5f">More...</a><br /></td></tr>
<tr class="separator:a3fef3bfa3e179035f17474007ace8c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7db20929172601b2c77430f89f1587c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#af7db20929172601b2c77430f89f1587c">subtreeEqual</a> (<a class="el" href="classBinTree_1_1Node.html">Node</a> *, <a class="el" href="classBinTree_1_1Node.html">Node</a> *) const </td></tr>
<tr class="memdesc:af7db20929172601b2c77430f89f1587c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two subtrees are considered equal if everything is identical.  <a href="#af7db20929172601b2c77430f89f1587c">More...</a><br /></td></tr>
<tr class="separator:af7db20929172601b2c77430f89f1587c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff6326f5602672393d717cab444aa02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#acff6326f5602672393d717cab444aa02">toStringInorder</a> (stringstream &amp;, <a class="el" href="classBinTree_1_1Node.html">Node</a> *) const </td></tr>
<tr class="memdesc:acff6326f5602672393d717cab444aa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">private helper for toString(), builds the output string recursively in order.  <a href="#acff6326f5602672393d717cab444aa02">More...</a><br /></td></tr>
<tr class="separator:acff6326f5602672393d717cab444aa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09db8fd76972b51c32d7478e3459a46a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a09db8fd76972b51c32d7478e3459a46a">sideways</a> (<a class="el" href="classBinTree_1_1Node.html">Node</a> *, int) const </td></tr>
<tr class="memdesc:a09db8fd76972b51c32d7478e3459a46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">private recursive helper to output the tree´s content  <a href="#a09db8fd76972b51c32d7478e3459a46a">More...</a><br /></td></tr>
<tr class="separator:a09db8fd76972b51c32d7478e3459a46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecd7435051c44d1ce24aef4d8b5d2d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a0ecd7435051c44d1ce24aef4d8b5d2d4">bstreeToArrayHelper</a> (<a class="el" href="classBinTree_1_1Node.html">Node</a> *, int *, <a class="el" href="classGeneric.html">Generic</a> *[])</td></tr>
<tr class="memdesc:a0ecd7435051c44d1ce24aef4d8b5d2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive helper to output subtrees into array  <a href="#a0ecd7435051c44d1ce24aef4d8b5d2d4">More...</a><br /></td></tr>
<tr class="separator:a0ecd7435051c44d1ce24aef4d8b5d2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a557be35ecea8cc17e765ae3b2acf335d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a557be35ecea8cc17e765ae3b2acf335d">root</a></td></tr>
<tr class="separator:a557be35ecea8cc17e765ae3b2acf335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe8166f7d5a39341c20878e05297403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#a3fe8166f7d5a39341c20878e05297403">nodeCount</a></td></tr>
<tr class="separator:a3fe8166f7d5a39341c20878e05297403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:add863127846d6aaccc8c5c4b5315e8e9"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinTree.html#add863127846d6aaccc8c5c4b5315e8e9">operator&lt;&lt;</a> (ostream &amp;, const <a class="el" href="classBinTree.html">BinTree</a> &amp;)</td></tr>
<tr class="memdesc:add863127846d6aaccc8c5c4b5315e8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded output operator  <a href="#add863127846d6aaccc8c5c4b5315e8e9">More...</a><br /></td></tr>
<tr class="separator:add863127846d6aaccc8c5c4b5315e8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Dynamic, list-based Binary Search Tree. The tree handles external data types via pointers. Proper functionality of the data structure assumes that the data class supports: &mdash; operator &gt; &lt; == != &mdash; operator&lt;&lt;</p>
<p>Data objects need to be instantiated external to the tree, in the client. The tree then handles storage, management, and destruction of the data. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ace8123d5e45d15164e5962184667d51a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BinTree::BinTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default constructor </p>
<p>creates an empty <a class="el" href="classBinTree.html">BinTree</a> </p>

</div>
</div>
<a class="anchor" id="a0142cad3ef4f3c340971f67b3a279056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BinTree::~BinTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Creates a copy of the passed in <a class="el" href="classBinTree.html">BinTree</a>. Uses a private helper routine to perform pre-order copy. Note: The copying procedure makes the node-connection manually along the way from top down. Utilizing <a class="el" href="classBinTree.html#aa469f4a964beb792cb138b9230567a78" title="inserts a value into the BinTree ">insert()</a> is simpler to code, but is less efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classBinTree.html">BinTree</a> tree to copy Private helper to build the tree recursively in pre-order.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates new content and stores it in one pass through the tree. No back-and-forth traversing involved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr</td><td>pointer to current <a class="el" href="classBinTree_1_1Node.html">Node</a> (root of the subtree to be built) </td></tr>
    <tr><td class="paramname">origCurr</td><td>pointer to the <a class="el" href="classBinTree_1_1Node.html">Node</a> with the original content to be copied. destructor</td></tr>
  </table>
  </dd>
</dl>
<p>releases all <a class="el" href="classBinTree.html">BinTree</a> Nodes' memory </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac6a2380532b0e7c44869c82732aaf7b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::arrayToBSTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&#160;</td>
          <td class="paramname"><em>nodeArray</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>conversion routine to input the data from an array into the tree </p>
<p>The data is inserted in a manner that creates a most balanced tree. Used together with bstreeToArray to achieve manual tree balancing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeArray</td><td>source storage of data. The array contains pointers to the data objects to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebc98226686df58f7cdacbc251956649"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::arrayToBSTreeHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&#160;</td>
          <td class="paramname"><em>nodeArray</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recursive helper to extract the middle element in each subarray. </p>
<p>Preorder insertion of medium data values creates a balanced tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeArray</td><td>source storage of data. </td></tr>
    <tr><td class="paramname">lo</td><td>first index of the subarray (inclusive) </td></tr>
    <tr><td class="paramname">hi</td><td>last index of the subarray (inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82b0e5e64e7d15a588f5435962029666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::bstreeToArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&#160;</td>
          <td class="paramname"><em>nodeArray</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>conversion routine to output the data in the tree into an array </p>
<p>The data is outputted in sorted order. </p><dl class="section pre"><dt>Precondition</dt><dd>Assumes that the array has sufficient space. Query for this info with the tree´s public <code><a class="el" href="classBinTree.html#a66a755f0ef440f55e989f407a0f7d02f" title="public getter for the size of the tree ">size()</a></code> method. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree is made empty after the content is extracted.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeArray</td><td>array of pointers (which are declared to point to the data type held in the tree data structure). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ecd7435051c44d1ce24aef4d8b5d2d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinTree_1_1Node.html">BinTree::Node</a> * BinTree::bstreeToArrayHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&#160;</td>
          <td class="paramname"><em>nodeArray</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recursive helper to output subtrees into array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>pointer to the root of the current subtree </td></tr>
    <tr><td class="paramname">index</td><td>reference to a counter variable global to the whole process </td></tr>
    <tr><td class="paramname">nodeArray</td><td>target storage location. The pointers contained in this array will be directed to the appropriate data objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current node after cleanup. Just an implementation detail. </dd></dl>

</div>
</div>
<a class="anchor" id="afcdc821a1313dc2ccf34a23fd0abd40b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::displaySideways </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Displays a binary tree as though you are viewing it from the side; hard coded displaying to standard output. </p>

</div>
</div>
<a class="anchor" id="a3fef3bfa3e179035f17474007ace8c5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BinTree::getArraySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&#160;</td>
          <td class="paramname"><em>nodeArray</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method to determine the size of an array of pointers </p>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes that the sensible data is stored at the front of the array. Search stops when NULL is met. </dd>
<dd>
Max supported array size: 100 (modifiable in tree´s header file)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeArray</td><td>the array of object pointers to be sized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the input pointer array </dd></dl>

</div>
</div>
<a class="anchor" id="a5855aafdb96ba09085ae305395b11589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BinTree::getDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public accessor to determine node's distance from root. </p>
<p>Definition: A node N is of depth d is there are a total of d nodes (inclusive) from the root to N.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td><a class="el" href="classGeneric.html">Generic</a> object (containing the desired content) to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating the "depth" the requested content in the tree, as defined above. Unsucessful search returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="abf448c3ebe63232b970dd8cec46118e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BinTree::getDepthHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private helper routine to support <a class="el" href="classBinTree.html#a5855aafdb96ba09085ae305395b11589" title="Public accessor to determine node&#39;s distance from root. ">getDepth()</a> recursively </p>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes existence of operator== for the data object </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>reference to the <a class="el" href="classGeneric.html">Generic</a> object containing the content to search for </td></tr>
    <tr><td class="paramname">cur</td><td>current root of subtree recursion </td></tr>
    <tr><td class="paramname">level</td><td>current depth of the subtree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int value indicating the depth of the subtree rooted at <code>cur</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8145fa386300e11439d2d3f4a44039a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinTree_1_1Node.html">BinTree::Node</a> * BinTree::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa469f4a964beb792cb138b9230567a78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts a value into the <a class="el" href="classBinTree.html">BinTree</a> </p>
<p>inserts a value into the <a class="el" href="classBinTree.html">BinTree</a>, adding a new entry if one does not already exist, and incrementing the entry if it does exist. Running time O(logn).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data object to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if insertion is successful, <code>false</code> otherwise. Insertion fails when new entry is equal to a parent with 2 children. </dd></dl>

</div>
</div>
<a class="anchor" id="a26b105deffaa22997cc27bb5c8f0360c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::insertHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper for the public <a class="el" href="classBinTree.html#aa469f4a964beb792cb138b9230567a78" title="inserts a value into the BinTree ">insert()</a> </p>
<p>recursively search for the position to insert, then insert it correctly once the base case is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node at which to start the search </td></tr>
    <tr><td class="paramname">token</td><td>The token to be inserted into the tree </td></tr>
    <tr><td class="paramname">frequency</td><td>the frequency that accompanies the token, also to be inserted into the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>insertion success status </dd></dl>

</div>
</div>
<a class="anchor" id="a9b5ce80f97bb63c0af4995f5917b3d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks for emptiness </p>
<p>checks to see if the <a class="el" href="classBinTree.html">BinTree</a> contains entries.</p>
<dl class="section return"><dt>Returns</dt><dd>returns <code>true</code> if the <a class="el" href="classBinTree.html">BinTree</a> is empty otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa51e54b66eaf1ef2195576c566acfba6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::makeEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>empty the tree completely </p>

</div>
</div>
<a class="anchor" id="af815543b5532e1acfe6734e3b69aa0ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBinTree.html">BinTree</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>just a boring re-use of operator== </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>reference to rhs tree to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two trees are different in content OR structure, <code>false</code> if they´re identical. </dd></dl>

</div>
</div>
<a class="anchor" id="a1174457deaf3f8cfb6887455f58f860f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinTree.html">BinTree</a> &amp; BinTree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBinTree.html">BinTree</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>makes a deep copy of the rhs with the copy constructor and swap private, internal resources. The copy goes out of scope by the end of the routine and destroys the lhs's old resources together with it, preventing memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>reference to the rhs tree to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the lhs tree </dd></dl>

</div>
</div>
<a class="anchor" id="a7570c08ff2a0af5b4ef1f15eb776475c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBinTree.html">BinTree</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classBinTree_1_1Node.html">Node</a> is an internal structure. We utilize its ... internality to define tree equality in a recursive manner. </p>

</div>
</div>
<a class="anchor" id="a604391bd9d790aa215c947260924546d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::postorderDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper for destructor </p>
<p>recursively delete the nodes in a tree from bottom up post-order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to delete and recurse on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86af32f56bdeba35f7d35d1e350dc7cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::preorderCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a23f846c419a9e9a98001389485253b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes an entry from the <a class="el" href="classBinTree.html">BinTree</a> </p>
<p>removes the specified entry from the <a class="el" href="classBinTree.html">BinTree</a> if it exists, and restructures the tree. Running time O(logn).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>entry value to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry is found and removed otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a61b7fde4a52e71c0d3720eb14b51da24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::removeHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method for <a class="el" href="classBinTree.html#a23f846c419a9e9a98001389485253b3e" title="removes an entry from the BinTree ">remove()</a> </p>
<p>recursively search for the parent of the removal target.<br />
Once found, remove it accordingly in 1 of 4 scenarios.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node potential to be the removal target's parent </td></tr>
    <tr><td class="paramname">rmToken</td><td>the removal target string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>removal success status </dd></dl>

</div>
</div>
<a class="anchor" id="aef4196f4ba0b47589d9a7374dcb04e8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::retrieve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>subroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private helper for <a class="el" href="classBinTree.html#aef4196f4ba0b47589d9a7374dcb04e8b" title="private helper for retrieve() ">retrieve()</a> </p>
<p>recursively determine the existence of the search value in the left/right subtrees, then report appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node on which to recursively search for token </td></tr>
    <tr><td class="paramname">token</td><td>token to search for in the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the token is contained in the tree, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adb4bc893858764d61ef993837ba94313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::retrieve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeneric.html">Generic</a> *&amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks to see if an entry is in the <a class="el" href="classBinTree.html">BinTree</a> </p>
<p>checks to see if the specified entry is in the <a class="el" href="classBinTree.html">BinTree</a> tree. Running time O(logn).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>entry to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if the entry is found otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="a09db8fd76972b51c32d7478e3459a46a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::sideways </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private recursive helper to output the tree´s content </p>
<dl class="section warning"><dt>Warning</dt><dd>hard-coded to only support standard output to the console</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>pointer to root of current subtree </td></tr>
    <tr><td class="paramname">level</td><td>level of current subtree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66a755f0ef440f55e989f407a0f7d02f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BinTree::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public getter for the size of the tree </p>
<dl class="section return"><dt>Returns</dt><dd>count of the tree nodes </dd></dl>

</div>
</div>
<a class="anchor" id="af7db20929172601b2c77430f89f1587c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BinTree::subtreeEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>subroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>otherSubroot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two subtrees are considered equal if everything is identical. </p>
<p>"Everything" includes: subroot, left subtree, and right subtree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subroot</td><td><a class="el" href="classBinTree_1_1Node.html">Node</a> pointer to the root of the subtree being compared </td></tr>
    <tr><td class="paramname">otherSubroot</td><td><a class="el" href="classBinTree_1_1Node.html">Node</a> pointer to the root of the rhs subtree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two subtrees are equal in content and structure <code>false</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="acff6326f5602672393d717cab444aa02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinTree::toStringInorder </td>
          <td>(</td>
          <td class="paramtype">stringstream &amp;&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBinTree_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>curr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private helper for toString(), builds the output string recursively in order. </p>
<p>dependency: stringstream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>stringstream reference, container for all the content strings </td></tr>
    <tr><td class="paramname">curr</td><td>pointer to current subtree's root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d7f9dd0dc2596d21cb2742819d3a480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string BinTree::toStringInorder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public toString() </p>
<dl class="section return"><dt>Returns</dt><dd>string representation of the tree's content, in order </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="add863127846d6aaccc8c5c4b5315e8e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBinTree.html">BinTree</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overloaded output operator </p>
<p>dependency: std::stringstream (not strict)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>ostream reference to be sent to the console </td></tr>
    <tr><td class="paramname">T</td><td>reference to the tree to be outputted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3fe8166f7d5a39341c20878e05297403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BinTree::nodeCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a557be35ecea8cc17e765ae3b2acf335d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinTree_1_1Node.html">Node</a>* BinTree::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="bintree_8h_source.html">bintree.h</a></li>
<li><a class="el" href="bintree_8cpp.html">bintree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 7 2014 00:02:03 for Inheritance and Polymorphism by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
